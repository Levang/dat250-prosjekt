# OWASP Top Ten
In this chapter we will go through the each prevention we have implemented for the the OWASP Top 10 vulnerabilities. Some of the OWASP 10 prevention measures are not implemented because they are not applicable or too complex to implement for this project. 

Every subsection title is the prevention measure as written in the OWASP Top 10 document [-@OWASP10]

## Injection

### The preferred option is to use a safe API, which avoids the use of the interpreter entirely or provides a parameterized interface, or migrate to use Object Relational Mapping Tools (ORMs).
We use the flask-API `flask_sqlalchemy` and strictly only query the database through it. This is not inherently safe on it's own, but used correctly it mitigates or completely eliminates the possibility of an SQL-injection attack.

Example:

```python
def getAccount(account_number):
    account: Account = Account.query.filter_by(number=account_number).first()
    return account
```

The above "query.filter_by" sanitizes input by default and is the only method used to query the database. The only exception being:

```python
#Sanetize input illegalChar(text,maxlength,"string Allowed chars")
illegal=illegalChar(transForm.accountSelect.data,11,"0123456789")

if (str(transForm.accountSelect.data) in str(accountList)) and illegal==False:
    query=Transactions.query.filter((Transactions.accountFrom == transForm.accountSelect.data) | (Transactions.accountTo == transForm.accountSelect.data))

    TransList=QueryToList(query, accountList, transForm.accountSelect.data)
else:
    pass
    #TODO LOG THIS!
```
Here we get input from the user about which account history the user wants to view. The method "query.filter" is not considered safe. Since the account number can be converted to an integer and back, any dangerous value would prevent this conversion, thus raise and exception and skip the query.
The account number is also looked up in the user's account list. These safety measures make this query safe.

### Use positive or "whitelist" server-side input validation. This is not a complete defense as many applications require special characters, such as text areas or APIs for mobile applications.

As seen in the example above, input validation is used to ensure database queries are safe from sql-injection. We specifically require there to be no special characters and for general input fields, we use an illegal character checking function:

It checks the input text character by character and only allows the characters that exists it the alphabet to be used.
In the above code you can see how its implemented and that it allowes nothing but numbers, not even spaces.
```python
def illegalChar(text, maxlength,alphabet="abcdefghijklmnopqrstuvwxyzæøå0123456789 "):
    if text==None:
        return False

    try:
        text=str(text)
    except:
        return True

    if len(text)>maxlength:
        return True

    #Transform name to lowercase and check if its not in the alphabet
    for letter in text.lower():
        if letter not in alphabet:
            return True
    return False
```

## Broken Authentication
Levang

### Where possible, implement multi-factor authentication to prevent automated, credential stuffing, brute force, and stolen credential re-use attacks.

### Where possible, implement multi-factor authentication to prevent automated, credential stuffing, brute force, and stolen credential re-use attacks.

### Implement weak-password checks, such as testing new or changed passwords against a list of the top 10000 worst passwords.

### Ensure registration, credential recovery, and API pathways are hardened against account enumeration attacks by using the same messages for all outcomes

### Use a server-side, secure,built-in session manager that generates a new random session ID with high entropy after login. Session IDs should not be in the URL, be securely stored and invalidated after logout, idle, and absolute timeouts.




## Sensitive Data Exposure
To limit the risk of data exposure, we attempt to handle as little personal information as possible. 


### Classify data processed, stored, or transmitted by an application. Identify which data is sensitive according to privacy laws, regulatory requirements, or business needs

### Apply controls as per the classification.

We separate the data we store into different database tables. The user table has the highest security requirement, while the transaction, account and logging tables demand lower security. The encryption and hashing of the tables are adjusted accordingly.

### Don’t store sensitive data unnecessarily.Discard it as soon as possible or use PCI DSS complianttokenization or even truncation. Data that is not retained cannot be stolen.

### Store passwords using strong adaptive and salted hashing functions with a work factor (delay factor), such as Argon2, scrypt, bcrypt, or PBKDF2. [-@OWASP10]

The password stored in the database is stored 

### Make sure to encrypt all sensitive data at rest.


### Disable caching for responses that contain sensitive data


The data we have to store that is sensitive is all cryptographically hashed, using a variety of Fernet and scrypt. In other words, our entire user table in our database is encrypted to some degree. Other information is not as sensitive as it is not personal information, and cannot be edited. A malicious actor knowing account-numbers and associated balances wouldn't make a difference as they wouldn't be able to do anything with it, as they wouldn't find out who owns the account. Passwords are stored as a scrypt hash with a random salt, with the possibility of having a work factor (delay variable) to it, so that it takes longer to brute-force passwords. Our random encryption key for various things is also encrypted using fernet and the users hashed password, meaning we can only decrypt data when given the users password, adding an extra layer of security.

To secure data in transit, we use HTTPS instead of the older HTTP.

Caching on all our sites is disabled. This prevents users form clicking "back" and finding sensitive data.

## XML External Entities (XXE)

## Broken Access Control

### With the exception of public resources, deny by default.

### Implement access control mechanisms once and re-use them throughout the application, including minimizing CORS usage.

### Model access controls should enforce record ownership, rather than accepting that the user can create, read, update, or delete any record.

### Rate limit API and controller access to minimize the harm from automated attack tooling  --- ARDIJAN

  Levang

## Security Misconfiguration





  Ardijan

## Cross-Site Scripting
  Ardijan

## Insecure Deserialization

### Isolating and running code that deserializes in low privilege environments when possible.


  Ardijan

## Using Components with known vulnerabilities
  Ardijan
  
### Remove unused dependencies, unnecessary features, components, files, and documentation.

### Monitor for libraries and components that are unmaintained or do not create security patches for older versions. If patching is not possible, consider deploying a virtual patchto monitor, detect, or protect against the discovered issue.



## Insufficient Logging & Monitoring
Levang

### Ensure that logs are generated in a format that can be easily consumed by a centralized log management solutions.

### Ensure high-value transactions have an audit trail with integrity controls to prevent tampering or deletion, such as append-only database tables or similar.


