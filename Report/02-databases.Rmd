# Databases

Our databases are designed with the assumption that a malicious actor could potentially get a hold of all of them and knows our source code. In a perfect world they would not be able to use any of this to extract any valuable information. 

The weakpoint is the fact that if an account number is known and an attacker has a hold of the database, it is very simple to look up the account balance in the **Accounts** table.

Some notation:

- `(a)` means the hash of `a` is stored.
- `((a))` means an encrypted form of `a` is stored.


## Users {#databases-users}

Users is a database of registered users, their 2fa `secret` key, and their accounts along with the keys to control those accounts. None of the sensitive information in this database should ever be stored in a plaintext state. It should optimally be cryptographically hashed, but for data that is not user supplied, at least encrypted using the information supplied by the user. Doing it that way means we get to encrypt user data and not store the key anywhere.

```
(email)  ((enEmail))  ((password))+salt ((enKey)) ((accounts))  ((secret))
```

- `email` is the users identifier. It is stored in in a hashed state by scrypt, without salt. This also increases security because the only way to find out which emails are registered is to brute force all emails which should hopefully take a long time because the hash is cryptographic. This comes at the cost of not knowing what emails are registered so any email notifications are impossible except for something like "There were multiple failed attempts at signing into your account" since the attacker actually provides the email in this case.

- `enEmail` is the users clear text email encrypted by our randomly generated Fernet key. EnEmail is mainly a method for for double checking if the users input is valid, as the normal `email` is hashed.

- `password+salt` is the users password. It is stored as a cryptographical hash of itself prepended to a salt. This prevents rainbow table attacks on the database. The `salt` is the only thing stored in plaintext and is a cryptographically random number. The salt is stored in the same database-entry as the password, appended to the end of it. The encrypted password and the salt are always the same length, due to this we can append, and split them as we need them.

- `enKey` is the users encryption-key that has been encrypted by the users hashed password. This way we can extract any information we need given we get the users password.

- `accounts` holds all information about which accounts the current user owns. This has been encrypted with the decrypted `enKey`, this way we only have a decrypted version of the accounts when the user supplies their password.

- `secret` is the secret key used to generate One Time Passcodes (OTP's). This has been encrypted with the decrypted `enKey`, this way we only have a decrypted version of the secret-key when the user supplies their password.

As shown all the data in this database table is very heavily encrypted. The idea is as stated earlier that a malicious actor *could* potentially get a hold of our database. While we certainly will always do everything we can to ensure both physical and digital access, the worst case scenario should always be considered.

## Accounts {#databases-accounts}

Accounts is a database containing all banking accounts registered and their balance. Accounts should be borderline "use and dispose" meaning they should be easy to create and not limited in supply.

```
account balance
```

- `account` is just the account number. For our bank we have the standard `xxxx yy zzzzc` format. 
    - `xxxx` is a bankregistrationnumber which identify the bank, and the associated department in the bank. For us those numbers are a random integer between 4100-4300.  
    - `yy` signify account type, where we have only one type, given the number 69. 
    - `zzzz` is the customer account number, and is also a randomint between 1000-9999, as this simply is a random number
    - `c` is the "control-digit" which is calculated normally by taking the the number of the 10 preceding digits, and doing modulo 11 on them, for our case we have done modulo 10.

- `balance` is simply the balance of the account.


## Transactions {#databases-transactions}

Transactions is a database containing all transactions that have been performed ever. It should contain no sensitive information.

```
accTo  accFrom  amount  message  time  eventID  sign
```

- `uid` is a unique transaction id associated with the account. This is included to make sure a signed transaction can only be counted once.

- `date` is the timestamp of when the transaction was made. Probably UNIX time.

- `timeout` is a timestamp of when the transaction should expire. This prevents transactions that fail being reused by a bad actor some time in the future.

- `from` is the account number that is transferring. It is stored as a cryptographic hash to prevent the backtracking discussed earlier.

- `to` is the account number that is receiving. It is stored as a cryptographic hash to prevent the backtracking discussed earlier.

- `amount` is the amount that is transferring. Note that this can not be more than the balance of the `from` account.

- `sign` is the signature of the transaction, signed with the `private_key` of the `from` account. If the transaction is changed in any way then this signature must also change, preventing transactions being reused.
