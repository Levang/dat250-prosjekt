
# Structure

To structure our website we make use of a number of various frameworks and tools to make everything work securely. Our website is built upon the popular python web-framework Flask. The main reason as to why we make use of an external framework such as Flask, is to maintain security by using a framework that has already been tried and tested by many industry professionals. It also has packages for all the functionality that is needed to make a functional website for many different types of applications, providing tools such as session-handling and easy database management.

## Encryption and hashing
For hashing our users password, we elected to use `Scrypt` over alternatives such as `bcrypt` and `argon2`.

As for encryption we have implemented Fernet into a few easy to use functions. Using fernet we encrypt user information such as email, 2FA-secret and which accounts belong to the user. This user information is encrypted using a fernet key which is then also encrypted using the users password. As a consequence, the users information can only be accessed when the password is given, this also denies maintainers access to user information.

\newpage

## Site structure

Figure 1 shows our sitemap. The only websites available without any form of authentication is the front page and register. From the register page we also render another html page to verify the users 2FA-token, as they need to get their 2FA token set up before being able to log in.

As illustrated below, there are two authentication walls, one for login, and one for completing transactions. Both of these require at least 2 factors to complete, those being by password, and TOTP (timed one-time passwords).

![This is an illutstration of the site layout of Safecoin.tech](report_assets/pagemap_safecoin.png) 

\newpage

## Tools & Packages

The tools and packages that are used to make Safecoin.tech:

### Two-Factor Authentication
For 2FA we use TOTP codes generated for the user in their authentication app of choice. To generate these codes we make use of the packages `pyotp` and `flask-qrcode`. The QR-code is there as a user-friendly way to add the 2FA code to their app.

#### flask-qrcode
The main reason why we elected to use `flask-qrcode` over any other qr-code making packages is that by using `flask-qrcode` we can generate the QR-link without saving it as an image on our server. We want to manage unencrypted sensitive data as rarely as possible. By generating the QR-code when its needed we reduce the window of opportunity an attacker has to a minimum. Access to this information by anyone other than the user would be a breach of security. This is because it contains information about the email, issuer, and ecret key, thus they would only need your password and defeat the purpose of two factor authentication.

Implementation:

Initialize QR-functionality in init.py
```python
QRcode(app)
```
We then make the QR-link as we need it, pass it on to the relevant html, passing into it the variable qr_link which holds the OTP authentication information that gets encoded into the QR-code.

The QR-code is then generated by this function directly in the html:
```html
<img src="{{ qrcode(qr_link) }}" alt="qr-kode">
```


#### pyotp - Python One-Time Password Library
To generate the link we use in the generated QR-code we use the `pyotp` package. Thus generating the QR-code with `flask-qrcode` is very simple, only a few lines of code are needed.

```python
secret_key = pyotp.random_base32()

qr_link = pyotp.totp.TOTP(secret_key).provisioning_uri(name=form.email.data, 
issuer_name="Safecoin.tech")
```

The secrey key is a randomly generated 16 character base32 secret that is compatible with Google authenticator and other OTP apps. These look like `'POAATUEFZ5O4RFSN'` and `'LCUSQXJLUMKYIDVF'` as examples.

To generate the QR-code using the link, we return the `qr_link` to the new html page:

```python
return render_template('TwoFactor.html', form2 = form2, qr_link = qr_link)
```
\newpage
#### Authentication app
In order to authenticate a user needs to make use of an OTP authentication app. Without this they will not be able to sign in, as 2FA is required at log in, or to complete transactions. Users are required to add their secret key to their OTP authentication app during registration, the QR-code makes this simple.


### Flask_Scrypt
`Flask_Scrypt` is a flask extension used to generate scrypt password hashes and random salts. The extension provides us with 3 functions that handle everything related to password management, generating salts and checking whether the provided password is the same as the one we have stored.


```python
generate_password_hash(password, salt, N=2**14, r=8, p=1, buflen=64)
generate_random_salt(byte_size=64)
check_password_hash(password, password_hash, salt, N=2**14, r=8, p=1, buflen=64)
```

These three functions make hashing simple.

![The approximate material hardware costs of breaking a password in 2002](report_assets/scrypt_table_cost.png) 
[-@Percival2009]

The table above shows an approximate cost of brute-forcing passwords with the specified length in 2002. While technology has advanced far beyond 2002, the table still functions as an approximate estimation on how scrypt compares to many other hashing algorithms.

The hashing algorithms `bcrypt` and `argon2` were also considered as alternatives to `scrypt`. After some research we relatively quickly decided that `scrypt` would be the best fit; It not only is secure, but also very easy to use. Bcrypt as can be seen in the table above, is far less secure. `Argon2` on the other hand was a real consideration. We landed on `Scrypt` because of its' better resistance to large scale brute force attacks. It manages this by not only scaling the cpu-usage, but the memory-usage as well. This approach makes it very expensive to execute a parallel brute force attacks.[-@Percival2009]
 

### flask_sqlalchemy
From SQLalchemy's website: "The main goal of SQLAlchemy is to change the way you think about databases and SQL!" SQLalchemy was designed to be for efficient and high-performing database access, adapted into a simple and pythonic language, in other words a tool designed to make database-management efficient and easy-to-use. The library automates redundant and time-consuming processes while the administrator retains the control of how the database is designed and how the SQL is constructed.[-@sqlalchemy]

We use `SQLalchemy` as it is such an easy and efficient tool, while at the same time eliminating the risk of SQL-injection attacks by sanitizing all queries by default. An alternative was to go for something like sqlite3, but this would potentially make it easy for us to make a mistake in how we structure our queries.

### flask_login
We use `flask-login` alongside redis to handle sessions. `Flask-login` handles logging in, logging out, as well as database queries for each request.

`Flask-login` is primarily used for:
- Handling active user ID's in the sessions, which allows us to easily log users in and out .
- Restrict views to logged-in (or logged-out) users.
- Help protect users' sessions from being stolen by cookie thieves.


By tapping into flask logins user classes we can easily control how it behaves by setting properties for:
```python
user.is_authenticated
user.is_active
user.is_anonymous
user.get_id()
```
is_authenticated and is_active are set up as properties that query redis, to check if the user exists in the dictionary or otherwise logs the user out.

`flask-login` provides a structured way to handle user authentication, permissions and data.


### WTForms & flask_wtf
`WTForms` along with `flask_wtf` handle all fields where we require user to input data, such as email, password, payment, KID/message-fields etc. 

`flask_wtf` handles the `FlaskForm` class, and we create children of these classes in order to customize them as needed. These can then be used to create the fields we need such as `StringField, PasswordField, BooleanField` etc. The functionality of these can then be further defined by using built in functionality, example:

```python
class LoginForm(FlaskForm):
    email = StringField('Email', validators=[DataRequired(), Email()], 
    render_kw={"placeholder": "email@example.com"})
    password = PasswordField('Password', validators=[DataRequired()], 
    render_kw={"placeholder": "password"})
    otp = IntegerField('Two-factor Authentication', validators=[DataRequired()], 
    render_kw={"placeholder": "Two-Factor Authentication"})
    remember = BooleanField('Remember me')
    submit = SubmitField('Login')
```

### base64
base64 binary to text encoding or vice versa.
Required by fernet.

### cryptography
Contains the fernet encrypt/decrypt functions that are imported.

### JSON
Redis requires dictionary entries to be in a string/byte format. 
Therefore we use this package to convert python dictionaries to a string and back.

### Redis
Redis is a local key value server used to store decrypted user information in a non-permanent manner.
The data is stored with an expiry date, usually set at maximum 15 minutes ahead. If the user cannot be found in the dictionary the user is effectively logged out.
 
